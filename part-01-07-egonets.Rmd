# Egocentric networks

In egocentric social network analysis (ESNA, for our book,) instead of dealing with a single network, we have as many networks as participants in the study. Egos--the main study subjects--are analyzed from the perspective of their local social network. For a more extended view of ESNA, look at Raffaele Vacca's <a href="https://raffaelevacca.github.io/egocentric-r-book/" target="_blank">"*Egocentric network analysis with R*"</a>.

In this chapter, I show how to work with one particular type of ESNA data: information generated by the tool <a href="https://networkcanvas.com/" target="_blank">Network Canvas</a>. You can download an "artificial" ZIP file containing the outputs from a Network Canvas project [here](data-raw/networkCanvasExport-fake.zip)[^netcanvas-file]. During the entire chapter, we assume that the ZIP file was extracted to the path `data-raw/egonets`. You can go ahead and extract the ZIP by point-and-click, or use the following R code to automate the process:

[^netcanvas-file]: I thank Jaqueline Kent-Marvick who provided me with what I used as a baseline to generate the artificial Network Canvas export.

```{r echo=FALSE, warning=FALSE, message=FALSE}
# To make the file available
if (dir.exists("docs/data-raw"))
  dir.create("docs/data-raw", recursive=TRUE)
file.copy(
  "data-raw/networkCanvasExport-fake.zip",
  "docs/data-raw/networkCanvasExport-fake.zip"
  )
```

```{r unzip}
unzip(
  zipfile = "data-raw/networkCanvasExport-fake.zip",
  exdir   = "data-raw/egonets"
  )
```

This will extract all the files in `networkCanvasExport-fake.zip` to the subfolder `egonets`. Let's take a look at the first few files:

```{r part-01-07-egonets-files}
head(list.files(path = "data-raw/egonets"))
```

As you can see, for each ego in the dataset there are four files:

- `...attributeList_Person.csv`: Attributes of the alters.

- `...edgeList_Knows.csv`: Edgelist indicating the ties between the alters.

- `...ego.csv`: Information about the egos.

- `...graphml`: And a <a href="https://en.wikipedia.org/wiki/GraphML" target="_blank">`graphml` file</a> that contains the egonets.

The next sections will illustrate, file by file, how to read the information into R, apply any required processing, and store the information for later use. We start with the `graphml` files.

## Network files (graphml)

The `graphml` files can be read directly with `igraph`'s `read_graph` function. The key is to take advantage of R's lists to avoid writing over and over the same block of code, and instead, manage the data through lists. 

Just like any data-reading function, `read_graph` function requires a file path to the network file. **The function we will use to list the required files is `list.files()`**:

```{r netread, message=FALSE}
# We start by loading igraph
library(igraph)

# Listing all the graphml files
graph_files <- list.files(
  path       = "data-raw/egonets", # Where are these files
  pattern    = "*.graphml",        # Specify a pattern for only listing graphml
  full.names = TRUE                # And we make sure we use the full name
                                   # (path.) Otherwise, we would only get names.
  )

# Taking a look at the first three files we got
graph_files[1:3]

# Applying igraph's read_graph
graphs <- lapply(
  X      = graph_files,       # List of files to read
  FUN    = read_graph,        # The function to apply
  format = "graphml"          # Argument passed to read_graph
  )
```

If the operation succeeded, then the previous code block should generate a list of `igraph` objects named `graphs`. Let's take a peek at the first two:

```{r}
graphs[[1]]
graphs[[2]]
```

As always, one of the first things we do with networks is visualize them. We will use the <a href="https://cran.r-project.org/package=netplot" target="_blank">`netplot` R package</a> (by yours truly) to draw the figures:

```{r plot-nets, message=FALSE, warning=FALSE}
library(netplot)
library(gridExtra)

# Graph layout is random
set.seed(1231)

# The grid.arrange allows putting multiple netplot graphs into the same page
grid.arrange(
  nplot(graphs[[1]]),
  nplot(graphs[[2]]),
  nplot(graphs[[3]]),
  nplot(graphs[[4]]),
  ncol = 2, nrow = 2
)
```

Great! Since nodes in our network have features, we can add a little bit of color. We will use the `eat_with_2` variable, which is coded as `TRUE` or `FALSE`. Vertex colors can be specified using the `vertex.color` argument of the `nplot` function. In our case, we will specify colors passing a vector of length equal to the number of nodes in the graph. Furthermore, since we will be doing this multiple times, it is worthwhile writing a function:

```{r plot-nets-colored}
# A function to color by the eat with variable
color_it <- function(net) {

  # Coding eat_with_2 to be 1 (FALSE) or 2 (TRUE)
  eatswith <- V(net)$eat_with_2

  # Subsetting the color
  ifelse(eatswith, "purple", "darkgreen")

}
```

This function takes two arguments: a network and a vector of two colors. Vertex attributes in `igraph` can be accessed through the `V(...)$...` function. For this example, to access the attribute `eat_with_2` in the network `net`, we type `V(net)$eat_with_2`. Finally, individuals who have `eat_with_2` equal to true will be colored `purple`, otherwise, if equal to `FALSE`, will be colored `darkgreen`. Before plotting the networks, let's see what we get when we access the `eat_with_2` attribute in the first graph:

```{r}
V(graphs[[1]])$eat_with_2
```

A logical vector. Now let's redraw the figures:

```{r part-01-07-plot-nets-colored}
grid.arrange(
  nplot(graphs[[1]], vertex.color = color_it(graphs[[1]])),
  nplot(graphs[[2]], vertex.color = color_it(graphs[[2]])),
  nplot(graphs[[3]], vertex.color = color_it(graphs[[3]])),
  nplot(graphs[[4]], vertex.color = color_it(graphs[[4]])),
  ncol = 2, nrow = 2
)
```

Since most of the time, we will be dealing with a large number of egonets, you may want to draw each network independently; the following code-block does exactly that. First, if needed, will create a folder to store the networks. Then, using the `lapply` function, it will use `netplot::nplot()` to draw the networks, add a legend, and save the graph as `.../graphml_[number].png`, where `[number]` will go from `01` to the total number of networks in `graphs`.

```{r plot-net-all, eval = FALSE}
if (!dir.exists("egonets/figs/egonets"))
  dir.create("egonets/figs/egonets", recursive = TRUE)

lapply(seq_along(graphs), function(i) {
  
  # Creating the device 
  png(sprintf("egonets/figs/egonets/graphml_%02i.png", i))  
  
  # Drawing the plot
  p <- nplot(
    graphs[[i]],
    vertex.color = color_it(graphs[[i]])
    )
  
  # Adding a legend
  p <- nplot_legend(
    p,
    labels = c("eats with: FALSE", "eats with: TRUE"),
    pch    = 21,
    packgrob.args = list(side = "bottom"),
    gp            = gpar(
      fill = c("darkgreen", "purple")
    ),
    ncol = 2
  )
  
  print(p)
  
  # Closing the device
  dev.off()
})
```


## Person files

```{r read-person}
library(data.table)

person_files <- list.files(
  path       = "data-raw/egonets",
  pattern    = "*Person.csv",
  full.names = TRUE
  )

persons <- lapply(person_files, fread)
```

Exploring the data

```{r}
persons <- rbindlist(persons)

# Histogram of age
library(ggplot2)
ggplot(persons, aes(x = age)) +
  geom_histogram()

hist(persons$age)
```

## Ego files

```{r read-ego}
ego_files <- list.files(
  path       = "data-raw/egonets",
  pattern    = "*ego.csv",
  full.names = TRUE
  )

egos <- lapply(ego_files, fread)

egos <- rbindlist(egos)
head(egos)
```

Some data processing

```{r egos-time}
# How much time?
egos[, total_time := sessionFinish - sessionStart]

ggplot(egos, aes(x = total_time)) +
  geom_histogram() +
  labs(x = "Time in minutes", y = "Count") +
  labs(title = "Total time spent by egos")
```

## Edgelist files

```{r read-edgelist}
edgelist_files <- list.files(
  path = "data-raw/egonets",
  pattern = "*Knows.csv",
  full.names = TRUE
  )

edgelists <- lapply(edgelist_files, fread)
edgelists <- rbindlist(edgelists)
```


## Putting all together

### Generating statistics

```{r gen-stats}
net_stats <- lapply(graphs, function(g) {
  
  # Calculating modularity
  groups <- cluster_edge_betweenness(g)
  
  # Computing the stats
  data.table(
    size      = vcount(g),
    edges     = ecount(g),
    nisolates = sum(degree(g) == 0),
    transit   = transitivity(g, type = "global"),
    modular   = modularity(groups)
  )
})

net_stats <- rbindlist(net_stats)
head(net_stats)
```

### Generating statistics based on ergm

```{r gen-stats-ergm}
library(intergraph)
library(ergm)

graphs_network <- lapply(graphs, asNetwork)

net_stats_ergm <- lapply(graphs_network, function(n) {
  
  s <- summary_formula(
    n ~ triangles +
      nodematch("gender_1") +
      nodematch("healthy_diet")
    )
  
  data.table(
    triangles       = s[1],
    gender_homoph   = s[2],
    healthyd_homoph = s[3]
  )
})

net_stats_ergm <- rbindlist(net_stats_ergm)
head(net_stats_ergm)
```

## Saving the data

```{r saving}
# Network attributes
master <- cbind(egos, net_stats, net_stats_ergm)
fwrite(master, file = "data/network_stats.csv")

# Networks
saveRDS(graphs, file = "data/networks_igraph.rds")
saveRDS(graphs_network, file = "data/networks_network.rds")

# Attributes
fwrite(persons, file = "data/persons.csv")
```

