[
["index.html", "Applied SNA with R Chapter 1 About this book", " Applied SNA with R George G. Vega Yon 2018-03-23 Chapter 1 About this book This book will be build as part of a workshop on Applied Social Network Analysis with R. Its contents will be populated as the sessions take place, and for now there is particular program that we will follow, instead, we have the following workflow: Participants will share their data and what they need to do with it. Based on their data, I’ll be preparing the sessions trying to show attendees how would I approach the problem, and at the same time, teach by example about the R language. Materials will be published on this website and, hopefully, video recordings of the sessions. At least in the first version, the book will be organized by session, this is, one chapter per session. All the book materials can be downloaded from https://github.com/gvegayon/appliedsnar In general, we will besides of R itself, we will be using R studio and the following R packages: dplyr for data management, stringr for data cleaning, and of course igraph, netdiffuseR (a bit of a bias here), and statnet for our neat network analysis.1 Some of you may be wondering “what about ggplot2 and friends? What about tidyverse”, well, my short answer is I jumped into R before all of that was that popular. When I started plots were all about lattice, and after a couple of years on that, about base R graphics. What I’m saying is that so far I have not find a compelling reason to leave my “old-practices” and embrace all the tidyverse movement (religion?).↩ "],
["introduction.html", "Chapter 2 Introduction", " Chapter 2 Introduction For this book we need the following R Core Team (2017b) Install R from CRAN: https://www.r-project.org/ (optional) Install Rstudio: https://rstudio.org While I find RStudio extreamly useful, it is not necesary to use it with R. References "],
["r-basics.html", "Chapter 3 R Basics ", " Chapter 3 R Basics "],
["what-is-r.html", "3.1 What is R", " 3.1 What is R A good reference book for both new and advanced user is “The Art of R programming” (Matloff 2011)2 References "],
["how-to-install-packages.html", "3.2 How to install packages", " 3.2 How to install packages Nowadays there are two ways of installing R packages (that I’m aware of), either using install.packages, which is a function shipped with R, or use the devtools R package to install a package from some remote repository other than CRAN, here is a couple of examples: # This will install the igraph package from CRAN &gt; install.packages(&quot;netdiffuseR&quot;) # This will install the bleeding-edge version from the project&#39;s github repo! &gt; devtools::install_github(&quot;USCCANA/netdiffuseR&quot;) The first one, using install.packages, installs the CRAN version of netdiffuseR, whereas the second installs whatever version is plublished on https://github.com/USCCANA/netdiffuseR, which is usually called the development version. In some cases users may want/need to install packages from command line as some packages need extra configuration to be installed. But we won’t need to look at it now. "],
["network-nomination-data.html", "Chapter 4 Network Nomination Data", " Chapter 4 Network Nomination Data The data can be downloaded from here. The codebook for the data provided here is in the appendix. This chapter’s goals are: Read the data into R, Create a network with it, Compute descriptive statistics Visualize the network "],
["data-preprocessing.html", "4.1 Data preprocessing", " 4.1 Data preprocessing 4.1.1 Reading the data into R R has several ways of reading data in. You data can be Raw plain files like CSV, tab delimited or specified by column width, for which you can use the readr package (Wickham, Hester, and Francois 2017); or it can be binary files like dta (Stata), Octave, SPSS, for which foreign (R Core Team 2017a) can be used; or it could be excel files in which case you should be using readxl (Wickham and Bryan 2017). In our case, the data for this session is in Stata format: library(foreign) # Reading the data dat &lt;- foreign::read.dta(&quot;03-sns.dta&quot;) # Taking a look at the data&#39;s first 5 columns and 5 rows dat[1:5, 1:10] ## photoid school hispanic female1 female2 female3 female4 grades1 grades2 ## 1 1 111 1 NA NA 0 0 NA NA ## 2 2 111 1 0 NA NA 0 3.0 NA ## 3 7 111 0 1 1 1 1 5.0 4.5 ## 4 13 111 1 1 1 1 1 2.5 2.5 ## 5 14 111 1 1 1 1 NA 3.0 3.5 ## grades3 ## 1 3.5 ## 2 NA ## 3 4.0 ## 4 2.5 ## 5 3.5 4.1.2 Creating a unique id for each participant Now suppose that we want to create a unique id using the school and photo id. In this case, since both variables are numeric, a good way of doing it is to encode the id such that, for example, the last three x numbers are the photoid and the first ones are the school id. To do this we need to take into account the range of the variables. Here, photoid has the following range: (photo_id_ran &lt;- range(dat$photoid)) ## [1] 1 2074 As the variable spans up to 2074, we need to set the last 4 units of the variable to store the photoid. We will use dplyr (Wickham et al. 2017) and magrittr (Bache and Wickham 2014)] (the pipe operator, %&gt;%) to create this variable, and we will call it… id (mind blowing, right?): library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:texreg&#39;: ## ## extract (dat %&lt;&gt;% mutate(id = school*10000 + photoid)) %&gt;% head %&gt;% select(school, photoid, id) ## school photoid id ## 1 111 1 1110001 ## 2 111 2 1110002 ## 3 111 7 1110007 ## 4 111 13 1110013 ## 5 111 14 1110014 ## 6 111 15 1110015 Wow, what happend in the last three lines of code! What is that %&gt;%? Well, that’s the piping operator, and it is a very nice way of writing nested function calls. In this case, instead of having write something like dat_filtered$id &lt;- dat_filtered$school*10000 + dat_filtered$photoid subset(head(dat_filtered), select = c(school, photoid, id)) References "],
["creating-a-network.html", "4.2 Creating a network", " 4.2 Creating a network We want to build a social network. For that, we either use an adjacency matrix or an edgelist. Each individual of the SNS data nomitated 19 friends from school. We will use those nominations to create the social network. In this case, we will create the network by coercing the dataset into an edgelist. 4.2.1 From survey to edgelist Let’s start by loading a couple of handy R packages for this task, tidyr (Wickham and Henry 2017), which we will use to reshape the data, and stringr (Wickham 2017), which we will use to process strings using regular expressions3. library(tidyr) library(stringr) Optionally, we can use the tibble type of object which is an alternative to the actual data.frame. This object is claimed to provide more efficient methods for matrices and data frames. dat &lt;- as_tibble(dat) What I like from tibbles is that when you print them on the console these actually look nice: dat ## # A tibble: 2,164 x 100 ## photoid school hispanic female1 female2 female3 female4 grades1 grades2 ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 111 1. NA NA 0 0 NA NA ## 2 2 111 1. 0 NA NA 0 3.00 NA ## 3 7 111 0. 1 1 1 1 5.00 4.50 ## 4 13 111 1. 1 1 1 1 2.50 2.50 ## 5 14 111 1. 1 1 1 NA 3.00 3.50 ## 6 15 111 1. 0 0 0 0 2.50 2.50 ## 7 20 111 1. 1 1 1 1 2.50 2.50 ## 8 22 111 1. NA NA 0 0 NA NA ## 9 25 111 0. 1 1 NA 1 4.50 3.50 ## 10 27 111 1. 0 NA 0 0 3.50 NA ## # ... with 2,154 more rows, and 91 more variables: grades3 &lt;dbl&gt;, ## # grades4 &lt;dbl&gt;, eversmk1 &lt;int&gt;, eversmk2 &lt;int&gt;, eversmk3 &lt;int&gt;, ## # eversmk4 &lt;int&gt;, everdrk1 &lt;int&gt;, everdrk2 &lt;int&gt;, everdrk3 &lt;int&gt;, ## # everdrk4 &lt;int&gt;, home1 &lt;int&gt;, home2 &lt;int&gt;, home3 &lt;int&gt;, home4 &lt;int&gt;, ## # sch_friend11 &lt;int&gt;, sch_friend12 &lt;int&gt;, sch_friend13 &lt;int&gt;, ## # sch_friend14 &lt;int&gt;, sch_friend15 &lt;int&gt;, sch_friend16 &lt;int&gt;, ## # sch_friend17 &lt;int&gt;, sch_friend18 &lt;int&gt;, sch_friend19 &lt;int&gt;, ## # sch_friend110 &lt;int&gt;, sch_friend111 &lt;int&gt;, sch_friend112 &lt;int&gt;, ## # sch_friend113 &lt;int&gt;, sch_friend114 &lt;int&gt;, sch_friend115 &lt;int&gt;, ## # sch_friend116 &lt;int&gt;, sch_friend117 &lt;int&gt;, sch_friend118 &lt;int&gt;, ## # sch_friend119 &lt;int&gt;, sch_friend21 &lt;int&gt;, sch_friend22 &lt;int&gt;, ## # sch_friend23 &lt;int&gt;, sch_friend24 &lt;int&gt;, sch_friend25 &lt;int&gt;, ## # sch_friend26 &lt;int&gt;, sch_friend27 &lt;int&gt;, sch_friend28 &lt;int&gt;, ## # sch_friend29 &lt;int&gt;, sch_friend210 &lt;int&gt;, sch_friend211 &lt;int&gt;, ## # sch_friend212 &lt;int&gt;, sch_friend213 &lt;int&gt;, sch_friend214 &lt;int&gt;, ## # sch_friend215 &lt;int&gt;, sch_friend216 &lt;int&gt;, sch_friend217 &lt;int&gt;, ## # sch_friend218 &lt;int&gt;, sch_friend219 &lt;int&gt;, sch_friend31 &lt;int&gt;, ## # sch_friend32 &lt;int&gt;, sch_friend33 &lt;int&gt;, sch_friend34 &lt;int&gt;, ## # sch_friend35 &lt;int&gt;, sch_friend36 &lt;int&gt;, sch_friend37 &lt;int&gt;, ## # sch_friend38 &lt;int&gt;, sch_friend39 &lt;int&gt;, sch_friend310 &lt;int&gt;, ## # sch_friend311 &lt;int&gt;, sch_friend312 &lt;int&gt;, sch_friend313 &lt;int&gt;, ## # sch_friend314 &lt;int&gt;, sch_friend315 &lt;int&gt;, sch_friend316 &lt;int&gt;, ## # sch_friend317 &lt;int&gt;, sch_friend318 &lt;int&gt;, sch_friend319 &lt;int&gt;, ## # sch_friend41 &lt;int&gt;, sch_friend42 &lt;int&gt;, sch_friend43 &lt;int&gt;, ## # sch_friend44 &lt;int&gt;, sch_friend45 &lt;int&gt;, sch_friend46 &lt;int&gt;, ## # sch_friend47 &lt;int&gt;, sch_friend48 &lt;int&gt;, sch_friend49 &lt;int&gt;, ## # sch_friend410 &lt;int&gt;, sch_friend411 &lt;int&gt;, sch_friend412 &lt;int&gt;, ## # sch_friend413 &lt;int&gt;, sch_friend414 &lt;int&gt;, sch_friend415 &lt;int&gt;, ## # sch_friend416 &lt;int&gt;, sch_friend417 &lt;int&gt;, sch_friend418 &lt;int&gt;, ## # sch_friend419 &lt;int&gt;, id &lt;dbl&gt; # Maybe too much piping... but its cool! net &lt;- dat %&gt;% select(id, school, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -school) %&gt;% filter(!is.na(content)) %&gt;% mutate( friendid = school*10000 + content, year = as.integer(str_extract(varname, &quot;(?&lt;=[a-z])[0-9]&quot;)), nnom = as.integer(str_extract(varname, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;)) ) Let’s take a look at this step by step: First, we subset the data: We want to keep id, school, sch_friend*. For the later we use the function starts_with (from the tidyselect package). This allows us to select all variables that starts with the word “sch_friend”, which means that sch_friend11, sch_friend12, ... will all be selected. dat %&gt;% select(id, school, starts_with(&quot;sch_friend&quot;)) ## # A tibble: 2,164 x 78 ## id school sch_friend11 sch_friend12 sch_friend13 sch_friend14 ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1110001. 111 NA NA NA NA ## 2 1110002. 111 424 423 426 289 ## 3 1110007. 111 629 505 NA NA ## 4 1110013. 111 232 569 NA NA ## 5 1110014. 111 582 134 41 592 ## 6 1110015. 111 26 488 81 138 ## 7 1110020. 111 528 NA 492 395 ## 8 1110022. 111 NA NA NA NA ## 9 1110025. 111 135 185 553 84 ## 10 1110027. 111 346 168 559 5 ## # ... with 2,154 more rows, and 72 more variables: sch_friend15 &lt;int&gt;, ## # sch_friend16 &lt;int&gt;, sch_friend17 &lt;int&gt;, sch_friend18 &lt;int&gt;, ## # sch_friend19 &lt;int&gt;, sch_friend110 &lt;int&gt;, sch_friend111 &lt;int&gt;, ## # sch_friend112 &lt;int&gt;, sch_friend113 &lt;int&gt;, sch_friend114 &lt;int&gt;, ## # sch_friend115 &lt;int&gt;, sch_friend116 &lt;int&gt;, sch_friend117 &lt;int&gt;, ## # sch_friend118 &lt;int&gt;, sch_friend119 &lt;int&gt;, sch_friend21 &lt;int&gt;, ## # sch_friend22 &lt;int&gt;, sch_friend23 &lt;int&gt;, sch_friend24 &lt;int&gt;, ## # sch_friend25 &lt;int&gt;, sch_friend26 &lt;int&gt;, sch_friend27 &lt;int&gt;, ## # sch_friend28 &lt;int&gt;, sch_friend29 &lt;int&gt;, sch_friend210 &lt;int&gt;, ## # sch_friend211 &lt;int&gt;, sch_friend212 &lt;int&gt;, sch_friend213 &lt;int&gt;, ## # sch_friend214 &lt;int&gt;, sch_friend215 &lt;int&gt;, sch_friend216 &lt;int&gt;, ## # sch_friend217 &lt;int&gt;, sch_friend218 &lt;int&gt;, sch_friend219 &lt;int&gt;, ## # sch_friend31 &lt;int&gt;, sch_friend32 &lt;int&gt;, sch_friend33 &lt;int&gt;, ## # sch_friend34 &lt;int&gt;, sch_friend35 &lt;int&gt;, sch_friend36 &lt;int&gt;, ## # sch_friend37 &lt;int&gt;, sch_friend38 &lt;int&gt;, sch_friend39 &lt;int&gt;, ## # sch_friend310 &lt;int&gt;, sch_friend311 &lt;int&gt;, sch_friend312 &lt;int&gt;, ## # sch_friend313 &lt;int&gt;, sch_friend314 &lt;int&gt;, sch_friend315 &lt;int&gt;, ## # sch_friend316 &lt;int&gt;, sch_friend317 &lt;int&gt;, sch_friend318 &lt;int&gt;, ## # sch_friend319 &lt;int&gt;, sch_friend41 &lt;int&gt;, sch_friend42 &lt;int&gt;, ## # sch_friend43 &lt;int&gt;, sch_friend44 &lt;int&gt;, sch_friend45 &lt;int&gt;, ## # sch_friend46 &lt;int&gt;, sch_friend47 &lt;int&gt;, sch_friend48 &lt;int&gt;, ## # sch_friend49 &lt;int&gt;, sch_friend410 &lt;int&gt;, sch_friend411 &lt;int&gt;, ## # sch_friend412 &lt;int&gt;, sch_friend413 &lt;int&gt;, sch_friend414 &lt;int&gt;, ## # sch_friend415 &lt;int&gt;, sch_friend416 &lt;int&gt;, sch_friend417 &lt;int&gt;, ## # sch_friend418 &lt;int&gt;, sch_friend419 &lt;int&gt; Then, we reshape it to long format: By transposing all the sch_friend* to long. We do this by means of the function gather (from the tidyr package). This is an alternative to the reshape function, and I personally find it easier to use. Let’s see how it works: dat %&gt;% select(id, school, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -school) ## # A tibble: 164,464 x 4 ## id school varname content ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1110001. 111 sch_friend11 NA ## 2 1110002. 111 sch_friend11 424 ## 3 1110007. 111 sch_friend11 629 ## 4 1110013. 111 sch_friend11 232 ## 5 1110014. 111 sch_friend11 582 ## 6 1110015. 111 sch_friend11 26 ## 7 1110020. 111 sch_friend11 528 ## 8 1110022. 111 sch_friend11 NA ## 9 1110025. 111 sch_friend11 135 ## 10 1110027. 111 sch_friend11 346 ## # ... with 164,454 more rows In this case the key parameter sets the name of the variable that will contain the name of the variable that was reshaped, while value is the name of the variable that will hold the content of the data (that’s why I named those like that). The -id, -school bit tells the function to “drop” those variables before reshaping, in other words, “reshape everything but id and school”. Also, notice that we passed from 2164 rows to 19 (nominations) * 2164 (subjects) * 4 (waves) = 164464 rows, as expected. As the nomination data can be empty for some cells, we need to take care of those cases, the NAs, so we filter the data: dat %&gt;% select(id, school, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -school) %&gt;% filter(!is.na(content)) ## # A tibble: 39,561 x 4 ## id school varname content ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1110002. 111 sch_friend11 424 ## 2 1110007. 111 sch_friend11 629 ## 3 1110013. 111 sch_friend11 232 ## 4 1110014. 111 sch_friend11 582 ## 5 1110015. 111 sch_friend11 26 ## 6 1110020. 111 sch_friend11 528 ## 7 1110025. 111 sch_friend11 135 ## 8 1110027. 111 sch_friend11 346 ## 9 1110029. 111 sch_friend11 369 ## 10 1110030. 111 sch_friend11 462 ## # ... with 39,551 more rows And finally, we create three new variables from this dataset: friendid, year, and nom_num (nomination number). All this using regular expressions: dat %&gt;% select(id, school, starts_with(&quot;sch_friend&quot;)) %&gt;% gather(key = &quot;varname&quot;, value = &quot;content&quot;, -id, -school) %&gt;% filter(!is.na(content)) %&gt;% mutate( friendid = school*10000 + content, year = as.integer(str_extract(varname, &quot;(?&lt;=[a-z])[0-9]&quot;)), nnom = as.integer(str_extract(varname, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;)) ) ## # A tibble: 39,561 x 7 ## id school varname content friendid year nnom ## &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 1110002. 111 sch_friend11 424 1110424. 1 1 ## 2 1110007. 111 sch_friend11 629 1110629. 1 1 ## 3 1110013. 111 sch_friend11 232 1110232. 1 1 ## 4 1110014. 111 sch_friend11 582 1110582. 1 1 ## 5 1110015. 111 sch_friend11 26 1110026. 1 1 ## 6 1110020. 111 sch_friend11 528 1110528. 1 1 ## 7 1110025. 111 sch_friend11 135 1110135. 1 1 ## 8 1110027. 111 sch_friend11 346 1110346. 1 1 ## 9 1110029. 111 sch_friend11 369 1110369. 1 1 ## 10 1110030. 111 sch_friend11 462 1110462. 1 1 ## # ... with 39,551 more rows The regular expression (?&lt;=[a-z]) matches a string that is preceeded by any letter from a to z, whereas the expression [0-9] matches a single number. Hence, from the string &quot;sch_friend12&quot;, the regular expression will only match the 1, as it is the only number followed by a letter. On the other hand, the expression (?&lt;=[a-z][0-9]) matches a string that is preceeded by a letter from a to z and a number from 0 to 9; and the expression [0-9]+ matches a string of numbers–so it could be more than one. Hence, from the string &quot;sch_friend12&quot;, we will get 2. We can actually se this str_extract(&quot;sch_friend12&quot;, &quot;(?&lt;=[a-z])[0-9]&quot;) ## [1] &quot;1&quot; str_extract(&quot;sch_friend12&quot;, &quot;(?&lt;=[a-z][0-9])[0-9]+&quot;) ## [1] &quot;2&quot; And finally, the as.integer function coerces the returning value from the str_extract function from character to integer. Now that we have this edgelist, we can create an igraph object 4.2.2 igraph network For coercing the edgelist into an igraph object, we will be using the graph_from_data_frame function in igraph (Csardi and Nepusz 2006). This function receives a data frame where the two first columns are sorce(ego) and target(alter), whether is it directed or not, and an optional data frame with vertices, in which’s first column should contain the vertex ids. Using the optional vertices argument is a good practice since by doing so you are telling the function what is the set of vertex ids that you are expecting to find. Using the original dataset, we will create a data frame name vertices: vertex_attrs &lt;- dat %&gt;% select(id, school, hispanic, female1, starts_with(&quot;eversmk&quot;)) Now, let’s now use the function graph_from_data_frame to create an igraph object: library(igraph) ig_year1 &lt;- net %&gt;% filter(year == &quot;1&quot;) %&gt;% select(id, friendid, nnom) %&gt;% graph_from_data_frame( vertices = vertex_attrs ) ## Error in graph_from_data_frame(., vertices = vertex_attrs): Some vertex names in edge list are not listed in vertex data frame Ups! It seems that individuals are making nominations to other students that were not included on the survery. How to solve that? Well, it all depends on what you need to do! In this case, we will go for the quietly-remove-em’-and-don’t-tell strategy: ig_year1 &lt;- net %&gt;% filter(year == &quot;1&quot;) %&gt;% # Extra line, all nominations must be in ego too. filter(friendid %in% id) %&gt;% select(id, friendid, nnom) %&gt;% graph_from_data_frame( vertices = vertex_attrs ) ig_year1 ## IGRAPH 2de8c7a DN-- 2164 9514 -- ## + attr: name (v/c), school (v/n), hispanic (v/n), female1 (v/n), ## | eversmk1 (v/n), eversmk2 (v/n), eversmk3 (v/n), eversmk4 (v/n), ## | nnom (e/n) ## + edges from 2de8c7a (vertex names): ## [1] 1110007-&gt;1110629 1110013-&gt;1110232 1110014-&gt;1110582 1110015-&gt;1110026 ## [5] 1110025-&gt;1110135 1110027-&gt;1110346 1110029-&gt;1110369 1110035-&gt;1110034 ## [9] 1110040-&gt;1110390 1110041-&gt;1110557 1110044-&gt;1110027 1110046-&gt;1110030 ## [13] 1110050-&gt;1110086 1110057-&gt;1110263 1110069-&gt;1110544 1110071-&gt;1110167 ## [17] 1110072-&gt;1110289 1110073-&gt;1110014 1110075-&gt;1110352 1110084-&gt;1110305 ## [21] 1110086-&gt;1110206 1110093-&gt;1110040 1110094-&gt;1110483 1110095-&gt;1110043 ## + ... omitted several edges So there we have, our network with 2164 nodes and 9514 edges. The next steps: get some descriptive stats and visualize our network. References "],
["network-descriptive-stats.html", "4.3 Network descriptive stats", " 4.3 Network descriptive stats While we could do all networks at once, in this part we will focus on computing some network statistics for one of the schools only. We start by school 111. The first question that you should be asking your self now is, “how can I get that information from the igraph object?.” Well, vertex attributes and edges attributes can be accessed via the V and E functions respectively; moreover, we can list what vertex/edge attributes are available: list.vertex.attributes(ig_year1) ## [1] &quot;name&quot; &quot;school&quot; &quot;hispanic&quot; &quot;female1&quot; &quot;eversmk1&quot; &quot;eversmk2&quot; ## [7] &quot;eversmk3&quot; &quot;eversmk4&quot; list.edge.attributes(ig_year1) ## [1] &quot;nnom&quot; Just like we would do with data frames, accessing vertex attributes is done via the dollar sign operator $ together with the V function, for example, accessing the first 10 elements of the variable hispanic can be done as follows: V(ig_year1)$hispanic[1:10] ## [1] 1 1 0 1 1 1 1 1 0 1 Now that you know how to access vertex attributes, we can get the network corresponding to school 111 by identifying which vertices are part of it and pass that information to the induced_subgraph function: # Which ids are from school 111? school111ids &lt;- which(V(ig_year1)$school == 111) # Creating a subgraph ig_year1_111 &lt;- induced_subgraph( graph = ig_year1, vids = school111ids ) The which function in R returns a vector of indices indicating which elements are true. In our case it will return a vector of indices of the vertices which have the attribute school equal to 111. Now that we have our subgraph, we can compute different centrality measures4 for each vertex and store them in the igraph object itself: # Computing centrality measures for each vertex V(ig_year1_111)$indegree &lt;- degree(ig_year1_111, mode = &quot;in&quot;) V(ig_year1_111)$outdegree &lt;- degree(ig_year1_111, mode = &quot;out&quot;) V(ig_year1_111)$closeness &lt;- closeness(ig_year1_111, mode = &quot;total&quot;) V(ig_year1_111)$betweeness &lt;- betweenness(ig_year1_111, normalized = TRUE) From here, we can go back to our old habits and get the set of vertex attributes as a data frame so we can compute some summary statistics on the centrality measurements that we just got # Extracting each vectex features as a data.frame stats &lt;- as_data_frame(ig_year1_111, what = &quot;vertices&quot;) # Computing quantiles for each variable stats_degree &lt;- with(stats, { cbind( indegree = quantile(indegree, c(.025, .5, .975)), outdegree = quantile(outdegree, c(.025, .5, .975)), closeness = quantile(closeness, c(.025, .5, .975)), betweeness = quantile(betweeness, c(.025, .5, .975)) ) }) stats_degree ## indegree outdegree closeness betweeness ## 2.5% 0 0 3.526640e-06 0.000000000 ## 50% 4 4 1.595431e-05 0.001879006 ## 97.5% 16 16 1.601822e-05 0.016591048 The with function is somewhat similar to what dplyr allows us to do when we want to work with the dataset but without mentioning its name everytime that we ask for a variable. Without using the with function, the previous could have been done as follows: stats_degree &lt;- cbind( indegree = quantile(stats$indegree, c(.025, .5, .975)), outdegree = quantile(stats$outdegree, c(.025, .5, .975)), closeness = quantile(stats$closeness, c(.025, .5, .975)), betweeness = quantile(stats$betweeness, c(.025, .5, .975)) ) Now we will compute some statistics at the graph level: cbind( size = vcount(ig_year1_111), nedges = ecount(ig_year1_111), density = edge_density(ig_year1_111), recip = reciprocity(ig_year1_111), centr = centr_betw(ig_year1_111)$centralization, pathLen = mean_distance(ig_year1_111) ) ## size nedges density recip centr pathLen ## [1,] 533 2638 0.009303277 0.3731513 0.02179154 4.23678 Triadic census triadic &lt;- triad_census(ig_year1_111) triadic ## [1] 24059676 724389 290849 3619 3383 4401 3219 ## [8] 2997 407 33 836 235 163 137 ## [15] 277 85 To get a nicer view of this, we can use a table that I retrieved from ?triad_census. Moreover, instead of looking a the raw counts, we can normalize the triadic object by its sum so we get proportions instead5 knitr::kable(cbind( Pcent = triadic/sum(triadic)*100, read.csv(&quot;triadic_census.csv&quot;) ), digits = 2) Pcent code description 95.88 003 A,B,C, the empty graph. 2.89 012 A-&gt;B, C, the graph with a single directed edge. 1.16 102 A&lt;-&gt;B, C, the graph with a mutual connection between two vertices. 0.01 021D A&lt;-B-&gt;C, the out-star. 0.01 021U A-&gt;B&lt;-C, the in-star. 0.02 021C A-&gt;B-&gt;C, directed line. 0.01 111D A&lt;-&gt;B&lt;-C. 0.01 111U A&lt;-&gt;B-&gt;C. 0.00 030T A-&gt;B&lt;-C, A-&gt;C. 0.00 030C A&lt;-B&lt;-C, A-&gt;C. 0.00 201 A&lt;-&gt;B&lt;-&gt;C. 0.00 120D A&lt;-B-&gt;C, A&lt;-&gt;C. 0.00 120U A-&gt;B&lt;-C, A&lt;-&gt;C. 0.00 120C A-&gt;B-&gt;C, A&lt;-&gt;C. 0.00 210 A-&gt;B&lt;-&gt;C, A&lt;-&gt;C. 0.00 300 A&lt;-&gt;B&lt;-&gt;C, A&lt;-&gt;C, the complete graph. For more information about the different centrality measurements, please take a look at the “Centrality” article on Wikipedia.↩ During our workshop, Prof. De la Haye suggested using \\({n \\choose 3}\\) as a normalizing constant. It turns out that sum(triadic) = choose(n, 3)! So either approach is correct.↩ "],
["plotting-the-network-in-igraph.html", "4.4 Plotting the network in igraph", " 4.4 Plotting the network in igraph 4.4.1 Single plot Let’s take a look at how does our network looks like when we use the default parameters in the plot method of the igraph object: plot(ig_year1) Figure 4.1: A not very nice network plot. This is what we get with the default parameters in igraph. Not very nice, right? A couple of things with this plot: We are looking at all schools simultaneously, which does not make sense. So, instead of plotting ig_year1, we will focus on ig_year1_111. All the vertices have the same size, and more over, are overalaping. So, instead of using the default size, we will size the vertices by indegree using the degree function, and passing the vector of degrees to vertex.size.6 Given the number of vertices in these networks, the labels are not useful here. So we will remove them by setting vertex.label = NA. Moreover, we will reduce the size of the arrows’ tip by setting edge.arrow.size = 0.25. And finally, we will set the color of each vertex to be a function of whether the individual is hispanic or not. For this last bit we need to go a bit more of programming: col_hispanic &lt;- V(ig_year1_111)$hispanic + 1 col_hispanic &lt;- coalesce(col_hispanic, 3) col_hispanic &lt;- c(&quot;steelblue&quot;, &quot;tomato&quot;, &quot;white&quot;)[col_hispanic] Line by line, we did the following: The first line added one to all no NA values, so that the 0s (non-hispanic) turned to 1s and the 1s (hispanic) turned to 2s. The second line replaced all NAs with the number 3, so that our vector col_hispanic now ranges from 1 to 3 with no NAs in it. In the last line we created a vector of colors. Essentially, what we are doing here is telling R to create a vector of length length(col_hispanic) by selecting elements by index from the vector c(&quot;steelblue&quot;, &quot;tomato&quot;, &quot;white&quot;). This way, if, for example, the first element of the vector col_hispanic was a 3, our new vector of colors would have a &quot;white&quot; in it. To make sure we know we are right, let’s print the first 10 elements of our new vector of colors together with the original hispanic column: cbind( original = V(ig_year1_111)$hispanic[1:10], colors = col_hispanic[1:10] ) ## original colors ## [1,] &quot;1&quot; &quot;tomato&quot; ## [2,] &quot;1&quot; &quot;tomato&quot; ## [3,] &quot;0&quot; &quot;steelblue&quot; ## [4,] &quot;1&quot; &quot;tomato&quot; ## [5,] &quot;1&quot; &quot;tomato&quot; ## [6,] &quot;1&quot; &quot;tomato&quot; ## [7,] &quot;1&quot; &quot;tomato&quot; ## [8,] &quot;1&quot; &quot;tomato&quot; ## [9,] &quot;0&quot; &quot;steelblue&quot; ## [10,] &quot;1&quot; &quot;tomato&quot; With our nice vector of colors, now we can pass it to plot.igraph (which we call implicitly by just calling plot), via the vertex.color argument: # Fancy graph set.seed(1) plot( ig_year1_111, vertex.size = degree(ig_year1_111)/10 +1, vertex.label = NA, edge.arrow.size = .25, vertex.color = col_hispanic ) Figure 4.2: Friends network in time 1 for school 111. Nice! So it does look better. The only problem is that we have a lot of isolates. Let’s try again by drawing the same plot without isolates. To do so we need to filter the graph, for which we will use the function induced_subgraph # Which vertices are not isolates? which_ids &lt;- which(degree(ig_year1_111, mode = &quot;total&quot;) &gt; 0) # Getting the subgraph ig_year1_111_sub &lt;- induced_subgraph(ig_year1_111, which_ids) # We need to get the same subset in col_hispanic col_hispanic &lt;- col_hispanic[which_ids] # Fancy graph set.seed(1) plot( ig_year1_111_sub, vertex.size = degree(ig_year1_111_sub)/5 +1, vertex.label = NA, edge.arrow.size = .25, vertex.color = col_hispanic ) Figure 4.3: Friends network in time 1 for school 111. The graph excludes isolates. Now that’s better! An interesting pattern that shows up is that individuals seem to cluster by whether they are hispanic or not. We can actually write this as a function so that, instead of us copying and pasting the code \\(n\\) times (supposing that we want to crate a plot similar to this \\(n\\) times). The next subsection does that. 4.4.2 Multiple plots When you are repeating yourself over and over again, it is a good idea to write down a sequence of commands as a function. In this case, since we will be running the same type of plot for all schools/waves, we write a function in which the only things that changes are: (a) the school id, and (b) the color of the nodes. myplot &lt;- function( net, schoolid, mindgr = 1, vcol = &quot;tomato&quot;, ...) { # Creating a subgraph subnet &lt;- induced_subgraph( net, which(degree(net, mode = &quot;all&quot;) &gt;= mindgr &amp; V(net)$school == schoolid) ) # Fancy graph set.seed(1) plot( subnet, vertex.size = degree(subnet)/5, vertex.label = NA, edge.arrow.size = .25, vertex.color = vcol, ... ) } The function definition: The myplot &lt;- function([arguments]) {[body of the function]} tells R that we are going to create a function called myplot. In the arguments part, we are declaring 4 specific arguments: net, schoolid, mindgr, and vcol. These are an igraph object, the school id, the minimum degree that a vertex must have to be included in the plot, and the color of the vertices. Notice that, as a difference from other programming languages, in R we don’t need to declare the types that these objects are. The elipsis object, ..., is a special object in R that allows us passing other arguments without us specifying which. In our case, if you take a look at the plot bit of the body of the function, you will see that we also added ...; this means that whatever other arguments (different from the ones that we explicitly defined) are passed to the function, these will be passed to the function plot, moreover, to the plot.gexf function (since the subnet object is actually an igraph object). In practice, this implies that we can, for example, set the argument edge.arrow.size when calling myplot, even though we did not included it in the function definition! (See ?dotsMethods in R for more details). In the following lines of code, using our new function, we will plot each schools’ network in the same plotting device (window) with the help of the par function, and add legend with the legend: # Plotting all together oldpar &lt;- par(no.readonly = TRUE) par(mfrow = c(2, 3), mai = rep(0, 4), oma= c(1, 0, 0, 0)) myplot(ig_year1, 111, vcol = &quot;tomato&quot;) myplot(ig_year1, 112, vcol = &quot;steelblue&quot;) myplot(ig_year1, 113, vcol = &quot;black&quot;) myplot(ig_year1, 114, vcol = &quot;gold&quot;) myplot(ig_year1, 115, vcol = &quot;white&quot;) par(oldpar) # A fancy legend legend( &quot;bottomright&quot;, legend = c(111, 112, 113, 114, 115), pt.bg = c(&quot;tomato&quot;, &quot;steelblue&quot;, &quot;black&quot;, &quot;gold&quot;, &quot;white&quot;), pch = 21, cex = 1, bty = &quot;n&quot;, title = &quot;School&quot; ) Figure 4.4: All 5 schools in time 1. Again, the graphs exclude isolates. So what happend here? oldpar &lt;- par(no.readonly = TRUE) This line stores the current parameters for plotting. Since we are going to be changing them, we better make sure we are able to go back!. par(mfrow = c(2, 3), mai = rep(0, 4), oma=rep(0, 4)) Here we are setting various things at the same time. mfrow specifies how many figures will be drawn and in what order, in particular, we are asking the plotting device to allow for 2*3 = 6 plots organized in 2 rows and 3 columns, and these will be drawn by row. mai specifies the size of the margins in inches. Setting all margins equal to zero (which is what we are doing now) gives more space to the network itself. The same is true for oma. See ?par for more info. myplot(ig_year1, ...) This is simply calling our plotting function. The neat part of this is that, since we set mfrow = c(2, 3), R takes care of distributing the plots in the device. par(oldpar) This line allows us to restore the plotting parameters. Figuring out what is the optimal vertex size is a bit tricky. Without getting too technical, there’s no other way of getting nice vertex size other than just playing with different values of it. A nice solution to this is using netdiffuseR::igraph_vertex_rescale which rescales the vertices so that these keep their aspect ratio to a predefined proportion of the screen.↩ "],
["statistical-tests.html", "4.5 Statistical tests", " 4.5 Statistical tests 4.5.1 Is nomination number correlated with indegree? Hypothesis: Individuals that on average are among the first nominations of their peers are more popular # Getting all the data in long format edgelist &lt;- as_long_data_frame(ig_year1) %&gt;% as_tibble # Computing indegree (again) and average nomination number # Include &quot;On a scale from one to five how close do you feel&quot; # Also for egocentric friends (A. Friends) indeg_nom_cor &lt;- group_by(edgelist, to, to_name, to_school) %&gt;% summarise( indeg = n(), nom_avg = 1/mean(nnom) ) %&gt;% rename( school = to_school ) indeg_nom_cor ## # A tibble: 1,561 x 5 ## # Groups: to, to_name [1,561] ## to to_name school indeg nom_avg ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2. 1110002 111 22 0.222 ## 2 3. 1110007 111 7 0.175 ## 3 4. 1110013 111 6 0.171 ## 4 5. 1110014 111 19 0.134 ## 5 6. 1110015 111 3 0.150 ## 6 7. 1110020 111 6 0.154 ## 7 9. 1110025 111 6 0.214 ## 8 10. 1110027 111 13 0.220 ## 9 11. 1110029 111 14 0.131 ## 10 12. 1110030 111 6 0.222 ## # ... with 1,551 more rows # Using pearson&#39;s correlation with(indeg_nom_cor, cor.test(indeg, nom_avg)) ## ## Pearson&#39;s product-moment correlation ## ## data: indeg and nom_avg ## t = -12.254, df = 1559, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## -0.3409964 -0.2504653 ## sample estimates: ## cor ## -0.2963965 save.image(&quot;03.rda&quot;) "],
["exponential-random-graph-models.html", "Chapter 5 Exponential Random Graph Models", " Chapter 5 Exponential Random Graph Models I strongly suggest reading the vignette included in the ergm R package vignette(&quot;ergm&quot;, package=&quot;ergm&quot;) So what are ERGMs anyway… The purpose of ERGMs, in a nutshell, is to describe parsimoniously the local selection forces that shape the global structure of a network. To this end, a network dataset, like those depicted in Figure 1, may be considered like the response in a regression model, where the predictors are things like “propensity for individuals of the same sex to form partnerships” or “propensity for individuals to form triangles of partnerships”. In Figure 1(b), for example, it is evident that the individual nodes appear to cluster in groups of the same numerical labels (which turn out to be students’ grades, 7 through 12); thus, an ERGM can help us quantify the strength of this intra-group effect. — (Hunter et al. 2008) Source: Hunter et al. (2008) The distribution of \\(\\mathbf{Y}\\) can be parameterized in the form \\[ {\\mbox{Pr}\\left(\\mathbf{Y}=\\mathbf{y}|\\theta, \\mathcal{Y}\\right)} = \\frac{{\\mbox{exp}\\left\\{\\theta^{\\mbox{T}}\\mathbf{g}(\\mathbf{y})\\right\\}}}{\\kappa\\left(\\theta, \\mathcal{Y}\\right)},\\quad\\mathbf{y}\\in\\mathcal{Y} \\tag{5.1} \\] Where \\(\\theta\\in\\Omega\\subset\\mathbb{R}^q\\) is the vector of model coefficients and \\(\\mathbf{g}(\\mathbf{y})\\) is a q-vector of statistics based on the adjacency matrix \\(\\mathbf{y}\\). Model (5.1) may be expanded by replacing \\(\\mathbf{g}(\\mathbf{y})\\) with \\(\\mathbf{g}(\\mathbf{y}, \\mathbf{X})\\) to allow for additional covariate information \\(\\mathbf{X}\\) about the network. The denominator, \\[ \\kappa\\left(\\theta,\\mathcal{Y}\\right) = \\sum_{\\mathbf{z}\\in\\mathcal{Y}}{\\mbox{exp}\\left\\{\\theta^{\\mbox{T}}\\mathbf{g}(\\mathbf{z})\\right\\}} \\] Is the normalizing factor that ensures that equation (5.1) is a legitimate probability distribution. Even after fixing \\(\\mathcal{Y}\\) to be all the networks that have size \\(n\\), the size of \\(\\mathcal{Y}\\) makes this type of models hard to estimate as there are \\(N = 2^{n(n-1)}\\) possible networks! (Hunter et al. 2008) Recent developments include new forms of de- pendency structures, to take into account more general neighborhood effects. These models relax the one-step Markovian dependence assumptions, allowing investigation of longer range configurations, such as longer paths in the network or larger cycles (Pattison and Robins 2002). Models for bipartite (Faust and Skvoretz 1999) and tripartite (Mische and Robins 2000) network structures have also been developed. (Hunter et al. 2008, 9) 5.0.1 A naive example In the simplest case, ergm is equivalent to a logistic regression library(ergm) ## Loading required package: network ## network: Classes for Relational Data ## Version 1.13.0 created on 2015-08-31. ## copyright (c) 2005, Carter T. Butts, University of California-Irvine ## Mark S. Handcock, University of California -- Los Angeles ## David R. Hunter, Penn State University ## Martina Morris, University of Washington ## Skye Bender-deMoll, University of Washington ## For citation information, type citation(&quot;network&quot;). ## Type help(&quot;network-package&quot;) to get started. ## ## ergm: version 3.8.0, created on 2017-08-18 ## Copyright (c) 2017, Mark S. Handcock, University of California -- Los Angeles ## David R. Hunter, Penn State University ## Carter T. Butts, University of California -- Irvine ## Steven M. Goodreau, University of Washington ## Pavel N. Krivitsky, University of Wollongong ## Martina Morris, University of Washington ## with contributions from ## Li Wang ## Kirk Li, University of Washington ## Skye Bender-deMoll, University of Washington ## Based on &quot;statnet&quot; project software (statnet.org). ## For license and citation information see statnet.org/attribution ## or type citation(&quot;ergm&quot;). ## NOTE: Versions before 3.6.1 had a bug in the implementation of the ## bd() constriant which distorted the sampled distribution somewhat. ## In addition, Sampson&#39;s Monks datasets had mislabeled vertices. See ## the NEWS and the documentation for more details. data(&quot;sampson&quot;) samplike ## Network attributes: ## vertices = 18 ## directed = TRUE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## total edges= 88 ## missing edges= 0 ## non-missing edges= 88 ## ## Vertex attribute names: ## cloisterville group vertex.names ## ## Edge attribute names: ## nominations y &lt;- sort(as.vector(as.matrix(samplike)))[-c(1:18)] glm(y~1, family=binomial(&quot;logit&quot;)) ## ## Call: glm(formula = y ~ 1, family = binomial(&quot;logit&quot;)) ## ## Coefficients: ## (Intercept) ## -0.9072 ## ## Degrees of Freedom: 305 Total (i.e. Null); 305 Residual ## Null Deviance: 367.2 ## Residual Deviance: 367.2 AIC: 369.2 ergm(samplike ~ edges) ## Evaluating log-likelihood at the estimate. ## ## ## MLE Coefficients: ## edges ## -0.9072 pr &lt;- mean(y) log(pr) - log(1-pr) # Logit function ## [1] -0.9071582 qlogis(pr) ## [1] -0.9071582 References "],
["estimation-of-ergms.html", "5.1 Estimation of ERGMs", " 5.1 Estimation of ERGMs The ultimate goal is to be able to do statistical inference on the proposed model. In a normal setting, we would be able to use Maximum-Likelihood-Estimation (MLE) which basically consists on finding the model parameters \\(\\theta\\) that, given the observed data, maximizes the likelihood of the model. Such is usually done by applying Newton’s method which requires been able to compute the log-likelihood of the model. This is a bit more complicated in ERGMs. In the case of ERGMs, since part of the likelihood involves a normalizing constant that is a function of all possible networks, this is not as straight forward as it is in the regular setting. This is why we rely on simulations. In statnet, the default estimation method is based on a method proposed by (???), Markov-Chain MLE, which uses Markov-Chain Monte Carlo for simulating networks and a modified version of the Newton-Raphson algorihm to do the paremeter estimation part. In general terms, the MC-MLE algorithm can be described as follows: Initialize the algorithm with an initial guess of \\(\\theta\\), call it \\(\\theta^{(t)}\\) While (no convergence) do: Using \\(\\theta^{(t)}\\), simulate \\(M\\) networks by means of small changes in the \\(\\mathbf{Y}_{obs}\\) (the observed network). This part is done by using an importance-sampling method which weights each proposed network by it’s likelihood conditional on \\(\\theta^{(t)}\\) With the networks simulated, we can do the Newton step to update the parameter \\(\\theta^{(t)}\\) (this is the iteration part in the ergm package): \\(\\theta^{(t)}\\to\\theta^{(t+1)}\\) If convergence has been reach (which usually means that \\(\\theta^{(t)}\\) and \\(\\theta^{(t + 1)}\\) are not very different), then stop, otherwise, go to step a. For more details see (Lusher, Koskinen, and Robins 2012; Admiraal and Handcock 2006; Snijders 2002; Wang et al. 2009) provides details on the algorithm used by PNet (which is the same as the one used in RSiena). (Lusher, Koskinen, and Robins 2012) provides a short discussion on differences between ergm and PNet. References "],
["the-ergm-package.html", "5.2 The ergm package", " 5.2 The ergm package The ergm R package (Handcock et al. 2017) From the previous section:7 library(igraph) library(magrittr) library(dplyr) load(&quot;03.rda&quot;) In this section we will use the ergm package (from the statnet suit of packages (Handcock et al. 2016)) suit, and the intergraph (Bojanowski 2015) package. The latter provides functions to go back and forth between igraph and network objects from the igraph and network packages respectively8 library(ergm) library(intergraph) As a rather important side note, the order in which R packages are loaded matters. Why is this important to mention now? Well, it turns out that at least a couple of functions in the network package have the same name of some functions in the igraph package. When the ergm package is loaded, since it depends on network, it will load the network package first, which will mask some functions in igraph. This becomes evident once you load ergm after loading igraph: The following objects are masked from ‘package:igraph’: add.edges, add.vertices, %c%, delete.edges, delete.vertices, get.edge.attribute, get.edges, get.vertex.attribute, is.bipartite, is.directed, list.edge.attributes, list.vertex.attributes, %s%, set.edge.attribute, set.vertex.attribute What are the implications of this? If you call the function list.edge.attributes for an object of class igraph R will return an error as the first function that matches that name comes from the network package! To avoid this you can use the double colon notation: igraph::list.edge.attributes(my_igraph_object) network::list.edge.attributes(my_network_object) Anyway… Using the asNetwork function, we can coerce the igraph object into a network object so we can use it with the ergm function: # Creating the new network network_111 &lt;- intergraph::asNetwork(ig_year1_111) # Running a simple ergm (only fitting edge count) ergm(network_111 ~ edges) ## [1] &quot;Warning: This network contains loops&quot; ## [1] &quot;Warning: This network contains loops&quot; ## [1] &quot;Warning: This network contains loops&quot; ## Evaluating log-likelihood at the estimate. ## ## MLE Coefficients: ## edges ## -4.732 So what happened here! We got a warning. It turns out that our network has loops (didn’t thought about it before!). Let’s take a look on that with the which_loop function E(ig_year1_111)[which_loop(ig_year1_111)] ## + 1/2638 edge from 64b9eb9 (vertex names): ## [1] 1110111-&gt;1110111 We can get rid of these using the igraph::-.igraph. Moreover, just to illustrate how it can be done, let’s get rid of the isolates using the same operator # Creating the new network network_111 &lt;- ig_year1_111 # Removing loops network_111 &lt;- network_111 - E(network_111)[which(which_loop(network_111))] # Removing isolates network_111 &lt;- network_111 - which(degree(network_111, mode = &quot;all&quot;) == 0) # Converting the network network_111 &lt;- intergraph::asNetwork(network_111) asNetwork(simplify(ig_year1_111)) ig_year1_111 %&gt;% simplify %&gt;% asNetwork References "],
["running-ergms.html", "5.3 Running ERGMs", " 5.3 Running ERGMs Proposed workflow: Estimate the simplest model, adding one variable at a time. After each estimation, run the mcmc.diagnostics function to see how good/bad behaved are the chains. Run the gof function to see how good is the model at matching the network’s structural statistics. What to use: control.ergms: Maximum number of iteration, seed for Pseudo-RNG, how many cores ergm.constraints: Where to sample the network from. Gives stability and (in some cases) faster convergence as by constraining the model you are reducing the sample size. Here is an example of a couple of models that we could compare9 ans0 &lt;- ergm( network_111 ~ edges + nodematch(&quot;hispanic&quot;) + nodematch(&quot;female1&quot;) + nodematch(&quot;eversmk1&quot;) + mutual , constraints = ~bd(maxout = 19), control = control.ergm( seed = 1, MCMLE.maxit = 10, parallel = 4, CD.maxit = 10 ) ) So what are we doing here: The model is controling for: edges Number of edges in the network (as opposed to its density) nodematch(&quot;some-variable-name-here&quot;) Includes a term that controls for homophily/heterophily mutual Number of mutual connections between \\((i, j), (j, i)\\). This can be related to, for example, triadic closure. For more on control parameters, see (Morris, Handcock, and Hunter 2008). ans1 &lt;- ergm( network_111 ~ edges + nodematch(&quot;hispanic&quot;) + nodematch(&quot;female1&quot;) + nodematch(&quot;eversmk1&quot;) , constraints = ~bd(maxout = 19), control = control.ergm( seed = 1, MCMLE.maxit = 10, parallel = 4, CD.maxit = 10 ) ) This example takes longer to compute ans2 &lt;- ergm( network_111 ~ edges + nodematch(&quot;hispanic&quot;) + nodematch(&quot;female1&quot;) + nodematch(&quot;eversmk1&quot;) + mutual + balance , constraints = ~bd(maxout = 19), control = control.ergm( seed = 1, MCMLE.maxit = 10, parallel = 4, CD.maxit = 10 ) ) Now, a nice trick to see all regressions in the same table, we can use the texreg package (Leifeld 2013) which supports ergm ouputs! library(texreg) screenreg(list(ans0, ans1, ans2)) ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. ## ## =============================================================== ## Model 1 Model 2 Model 3 ## --------------------------------------------------------------- ## edges -5.63 *** -5.53 *** -5.56 *** ## (0.06) (0.06) (0.05) ## nodematch.hispanic 0.37 *** 0.51 *** 0.38 *** ## (0.04) (0.04) (0.04) ## nodematch.female1 0.82 *** 1.10 *** 0.83 *** ## (0.04) (0.05) (0.04) ## nodematch.eversmk1 0.33 *** 0.47 *** 0.35 *** ## (0.04) (0.04) (0.04) ## mutual 4.09 *** -4.76 *** ## (0.07) (0.25) ## balance 0.02 *** ## (0.00) ## --------------------------------------------------------------- ## AIC -37835.55 -35862.16 -37902.94 ## BIC -37785.21 -35821.88 -37842.53 ## Log Likelihood 18922.78 17935.08 18957.47 ## =============================================================== ## *** p &lt; 0.001, ** p &lt; 0.01, * p &lt; 0.05 Or, if you are using rmarkdown, you can export the results using LaTeX or html, let’s try the latter to see how it looks like here: library(texreg) htmlreg(list(ans0, ans1, ans2)) ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. ## Note: The constraint on the sample space is not dyad-independent. Null model likelihood is only implemented for dyad-independent constraints at this time. Number of observations is similarly ill-defined. Statistical models Model 1 Model 2 Model 3 edges -5.63*** -5.53*** -5.56*** (0.06) (0.06) (0.05) nodematch.hispanic 0.37*** 0.51*** 0.38*** (0.04) (0.04) (0.04) nodematch.female1 0.82*** 1.10*** 0.83*** (0.04) (0.05) (0.04) nodematch.eversmk1 0.33*** 0.47*** 0.35*** (0.04) (0.04) (0.04) mutual 4.09*** -4.76*** (0.07) (0.25) balance 0.02*** (0.00) AIC -37835.55 -35862.16 -37902.94 BIC -37785.21 -35821.88 -37842.53 Log Likelihood 18922.78 17935.08 18957.47 p &lt; 0.001, p &lt; 0.01, p &lt; 0.05 References "],
["model-goodness-of-fit.html", "5.4 Model Goodness-of-Fit", " 5.4 Model Goodness-of-Fit In raw terms, once each chain has reach stationary distribution, we can say that there are no problems with autocorrelation and that each sample point is iid. This implies that, since we are running the model with more than 1 chain, we can use all the samples (chains) as a single dataset. Recent changes in the ergm estimation algorithm mean that these plots can no longer be used to ensure that the mean statistics from the model match the observed network statistics. For that functionality, please use the GOF command: gof(object, GOF=~model). —?ergm::mcmc.diagnostics Since ans0 is the one model which did best, let’s take a look at it’s GOF statistics. First, lets see how the MCMC did. For this we can use the mcmc.diagnostics function including in the package. This function is actually a wrapper of a couple of functions from the coda package (Plummer et al. 2006) which is called upon the $sample object which holds the centered statistics from the sampled networks. This last point is important to consider since at first look it can be confusing to look at the $sample object since it neither matches the observed statistics, nor the coefficients. When calling the function mcmc.diagnostics(ans0, centered = FALSE), you will see a lot of output including a couple of plots showing the trace and posterior distribution of the uncentered statistics (centered = FALSE). In the next code chunks we will reproduce the output from the mcmc.diagnostics function step by step using the coda package. First we need to uncenter the sample object: # Getting the centered sample sample_centered &lt;- ans0$sample # Getting the observed statistics and turning it into a matrix so we can add it # to the samples observed &lt;- summary(ans0$formula) observed &lt;- matrix( observed, nrow = nrow(sample_centered[[1]]), ncol = length(observed), byrow = TRUE ) # Now we uncenter the sample sample_uncentered &lt;- lapply(sample_centered, function(x) { x + observed }) # We have to make it an mcmc.list object sample_uncentered &lt;- coda::mcmc.list(sample_uncentered) This is what is called under the hood: Empirical means and sd, and quantiles: summary(sample_uncentered) ## ## Iterations = 16384:1063936 ## Thinning interval = 1024 ## Number of chains = 4 ## Sample size per chain = 1024 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## edges 2442.7 51.14 0.7990 3.557 ## nodematch.hispanic 1588.2 39.08 0.6106 2.879 ## nodematch.female1 1786.0 44.92 0.7018 3.678 ## nodematch.eversmk1 1707.0 45.59 0.7123 3.420 ## mutual 471.6 20.47 0.3199 3.120 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## edges 2347 2407 2440 2476 2550 ## nodematch.hispanic 1515 1561 1588 1613 1668 ## nodematch.female1 1699 1755 1785 1816 1879 ## nodematch.eversmk1 1622 1675 1705 1739 1797 ## mutual 431 459 470 485 515 Cross correlation: coda::crosscorr(sample_uncentered) ## edges nodematch.hispanic nodematch.female1 ## edges 1.0000000 0.7842851 0.8454275 ## nodematch.hispanic 0.7842851 1.0000000 0.6875136 ## nodematch.female1 0.8454275 0.6875136 1.0000000 ## nodematch.eversmk1 0.8278077 0.6009145 0.6802329 ## mutual 0.6761018 0.5362456 0.6581912 ## nodematch.eversmk1 mutual ## edges 0.8278077 0.6761018 ## nodematch.hispanic 0.6009145 0.5362456 ## nodematch.female1 0.6802329 0.6581912 ## nodematch.eversmk1 1.0000000 0.6111560 ## mutual 0.6111560 1.0000000 Autocorrelation: Just for now, we will only take a look at autocorrelation for chain 1 only. Autocorrelation should be rather low (in a general MCMC setting). If autocorrelation is high, then it means that your sample is not idd (no markov property). A way out to solve this is thinning the sample. coda::autocorr(sample_uncentered)[[1]] ## , , edges ## ## edges nodematch.hispanic nodematch.female1 ## Lag 0 1.0000000 0.8219687 0.8705328 ## Lag 1024 0.8897580 0.7344981 0.7849176 ## Lag 5120 0.6125344 0.5093458 0.5843733 ## Lag 10240 0.4944537 0.4263616 0.5010519 ## Lag 51200 0.2553223 0.2028499 0.2945153 ## nodematch.eversmk1 mutual ## Lag 0 0.8679762 0.6494130 ## Lag 1024 0.7854503 0.6389852 ## Lag 5120 0.5671411 0.5952745 ## Lag 10240 0.4775676 0.5432361 ## Lag 51200 0.2399202 0.3539473 ## ## , , nodematch.hispanic ## ## edges nodematch.hispanic nodematch.female1 ## Lag 0 0.8219687 1.0000000 0.7213715 ## Lag 1024 0.7273184 0.8790036 0.6501736 ## Lag 5120 0.4679330 0.5328138 0.4685746 ## Lag 10240 0.3548131 0.3719475 0.3735284 ## Lag 51200 0.2275837 0.2027639 0.2450665 ## nodematch.eversmk1 mutual ## Lag 0 0.6933735 0.5332499 ## Lag 1024 0.6242548 0.5214353 ## Lag 5120 0.4278511 0.4686949 ## Lag 10240 0.3486120 0.4199291 ## Lag 51200 0.2193803 0.2047705 ## ## , , nodematch.female1 ## ## edges nodematch.hispanic nodematch.female1 ## Lag 0 0.8705328 0.7213715 1.0000000 ## Lag 1024 0.7882288 0.6530082 0.9067042 ## Lag 5120 0.5848867 0.4701031 0.6960912 ## Lag 10240 0.5143759 0.4415248 0.6162009 ## Lag 51200 0.2943576 0.2717081 0.3756573 ## nodematch.eversmk1 mutual ## Lag 0 0.7737254 0.6670677 ## Lag 1024 0.7116355 0.6624944 ## Lag 5120 0.5435839 0.6422426 ## Lag 10240 0.4804301 0.6076076 ## Lag 51200 0.2807997 0.3770320 ## ## , , nodematch.eversmk1 ## ## edges nodematch.hispanic nodematch.female1 ## Lag 0 0.8679762 0.6933735 0.7737254 ## Lag 1024 0.7848037 0.6274016 0.7117444 ## Lag 5120 0.5581929 0.4628434 0.5535105 ## Lag 10240 0.4779814 0.3987335 0.4923237 ## Lag 51200 0.2846086 0.2285842 0.3260756 ## nodematch.eversmk1 mutual ## Lag 0 1.0000000 0.5893853 ## Lag 1024 0.9073188 0.5852995 ## Lag 5120 0.6557095 0.5659845 ## Lag 10240 0.5476628 0.5493667 ## Lag 51200 0.2846972 0.4000402 ## ## , , mutual ## ## edges nodematch.hispanic nodematch.female1 ## Lag 0 0.6494130 0.5332499 0.6670677 ## Lag 1024 0.6513036 0.5378887 0.6639583 ## Lag 5120 0.6380464 0.5446367 0.6412776 ## Lag 10240 0.6214549 0.5353477 0.6214122 ## Lag 51200 0.3647324 0.2297713 0.4240353 ## nodematch.eversmk1 mutual ## Lag 0 0.5893853 1.0000000 ## Lag 1024 0.5878446 0.9884291 ## Lag 5120 0.5696277 0.9396082 ## Lag 10240 0.5458346 0.8806506 ## Lag 51200 0.2897837 0.3673476 Geweke Diagnostic: From the function’s help file: “If the samples are drawn from the stationary distribution of the chain, the two means are equal and Geweke’s statistic has an asymptotically standard normal distribution. […] The Z-score is calculated under the assumption that the two parts of the chain are asymptotically independent, which requires that the sum of frac1 and frac2 be strictly less than 1.”&quot; —?coda::geweke.diag Let’s take a look at a single chain: coda::geweke.diag(sample_uncentered)[[1]] ## ## Fraction in 1st window = 0.1 ## Fraction in 2nd window = 0.5 ## ## edges nodematch.hispanic nodematch.female1 ## 1.2158 1.9078 1.0548 ## nodematch.eversmk1 mutual ## 1.6781 0.4969 (not included) Gelman Diagnostic: From the function’s help file: Gelman and Rubin (1992) propose a general approach to monitoring convergence of MCMC output in which m &gt; 1 parallel chains are run with starting values that are overdispersed relative to the posterior distribution. Convergence is diagnosed when the chains have ‘forgotten’ their initial values, and the output from all chains is indistinguishable. The gelman.diag diagnostic is applied to a single variable from the chain. It is based a comparison of within-chain and between-chain variances, and is similar to a classical analysis of variance. —?coda::gelman.diag As a difference from the previous diagnostic statistic, this uses all chains simulatenously: coda::gelman.diag(sample_uncentered) ## Potential scale reduction factors: ## ## Point est. Upper C.I. ## edges 1.23 1.60 ## nodematch.hispanic 1.13 1.36 ## nodematch.female1 1.13 1.35 ## nodematch.eversmk1 1.21 1.58 ## mutual 1.42 2.08 ## ## Multivariate psrf ## ## 1.41 As a rule of thumb, values that are in the \\([.9,1.1]\\) are good. One nice feature of the mcmc.diagnostics function is the nice trace and posterior distribution plots that it generates. If you have the R package latticeExtra (Sarkar and Andrews 2016), the function will override the default plots used by coda::plot.mcmc and use lattice instead, creating a nicer looking plots. The next code chunk calls the mcmc.diagnostic function, but we suppress the rest of the output (see figure 5.1). mcmc.diagnostics(ans0, center = FALSE) # Suppressing all the output Figure 5.1: Trace and posterior distribution of sampled network statistics. Figure 5.1: Trace and posterior distribution of sampled network statistics (cont’d). If we called the function mcmc.diagnostics this message appears at the end: MCMC diagnostics shown here are from the last round of simulation, prior to computation of final parameter estimates. Because the final estimates are refinements of those used for this simulation run, these diagnostics may understate model performance. To directly assess the performance of the final model on in-model statistics, please use the GOF command: gof(ergmFitObject, GOF=~model). —mcmc.diagnostics(ans0) Not that bad (although the mutual term could do better)!10 First, observe that in the plot we see 4 different lines, why is that? Well, since we were running in parallel using 4 cores the algorithm actually ran 4 different chains of the MCMC algorithm. An eyeball test is to see if all the chains moved at about the same place, if we have that we can start thinking about model convergence from the mcmc perspective. Once we are sure to have reach convergence on the MCMC algorithm, we can start thinking about how well does our model predicts the observed network’s proterties. Besides of the statistics that define our ERGM, the gof function’s default behavior show GOF for: In degree distribution, Out degree distribution, Edge-wise shared partners, and Geodesics Let’s take a look at it # Computing and printing GOF estatistics ans_gof &lt;- gof(ans0) ans_gof ## ## Goodness-of-fit for in-degree ## ## obs min mean max MC p-value ## 0 13 0 1.87 6 0.00 ## 1 34 2 8.25 18 0.00 ## 2 37 11 21.50 31 0.00 ## 3 48 27 39.39 52 0.16 ## 4 37 38 55.15 78 0.00 ## 5 47 47 62.90 84 0.02 ## 6 42 47 63.23 85 0.00 ## 7 39 40 53.80 70 0.00 ## 8 35 25 41.40 59 0.30 ## 9 21 17 29.61 41 0.08 ## 10 12 8 18.62 28 0.24 ## 11 19 4 10.80 19 0.02 ## 12 4 2 6.18 12 0.62 ## 13 7 0 3.14 9 0.16 ## 14 6 0 1.23 5 0.00 ## 15 3 0 0.50 2 0.00 ## 16 4 0 0.32 3 0.00 ## 17 3 0 0.10 2 0.00 ## 18 3 0 0.00 0 0.00 ## 19 2 0 0.01 1 0.00 ## 20 1 0 0.00 0 0.00 ## 22 1 0 0.00 0 0.00 ## ## Goodness-of-fit for out-degree ## ## obs min mean max MC p-value ## 0 4 0 1.73 5 0.18 ## 1 28 1 8.93 16 0.00 ## 2 45 13 20.98 34 0.00 ## 3 50 27 39.60 54 0.12 ## 4 54 38 55.06 69 0.94 ## 5 62 46 62.52 78 0.98 ## 6 40 50 62.49 81 0.00 ## 7 28 37 54.67 72 0.00 ## 8 13 31 42.24 54 0.00 ## 9 16 16 28.97 41 0.02 ## 10 20 6 18.74 28 0.82 ## 11 8 5 10.71 17 0.50 ## 12 11 1 6.09 12 0.10 ## 13 13 0 2.78 7 0.00 ## 14 6 0 1.48 6 0.02 ## 15 6 0 0.57 3 0.00 ## 16 7 0 0.23 2 0.00 ## 17 4 0 0.10 1 0.00 ## 18 3 0 0.08 1 0.00 ## 19 0 0 0.03 1 1.00 ## ## Goodness-of-fit for edgewise shared partner ## ## obs min mean max MC p-value ## esp0 1032 1996 2252.28 2357 0 ## esp1 755 165 241.97 407 0 ## esp2 352 6 14.98 81 0 ## esp3 202 0 0.66 15 0 ## esp4 79 0 0.01 1 0 ## esp5 36 0 0.00 0 0 ## esp6 14 0 0.00 0 0 ## esp7 4 0 0.00 0 0 ## esp8 1 0 0.00 0 0 ## ## Goodness-of-fit for minimum geodesic distance ## ## obs min mean max MC p-value ## 1 2475 2374 2509.90 2667 0.58 ## 2 10672 12763 14421.15 16321 0.00 ## 3 31134 51730 58783.98 66543 0.00 ## 4 50673 75774 78515.61 81865 0.00 ## 5 42563 11964 17516.75 24191 0.00 ## 6 18719 303 968.19 1928 0.00 ## 7 4808 0 32.79 346 0.00 ## 8 822 0 1.50 48 0.00 ## 9 100 0 0.08 4 0.00 ## 10 7 0 0.00 0 0.00 ## Inf 12333 0 1556.05 3322 0.00 ## ## Goodness-of-fit for model statistics ## ## obs min mean max MC p-value ## edges 2475 2374 2509.90 2667 0.58 ## nodematch.hispanic 1615 1545 1641.50 1757 0.64 ## nodematch.female1 1814 1710 1837.83 1927 0.56 ## nodematch.eversmk1 1738 1653 1758.92 1849 0.74 ## mutual 486 449 496.92 542 0.74 # Plotting GOF statistics plot(ans_gof) Try the following configuration instead ans0_bis &lt;- ergm( network_111 ~ edges + nodematch(&quot;hispanic&quot;) + nodematch(&quot;female1&quot;) + mutual + esp(0:3) + idegree(0:10) , constraints = ~bd(maxout = 19), control = control.ergm( seed = 1, MCMLE.maxit = 15, parallel = 4, CD.maxit = 15, MCMC.samplesize = 2048*4, MCMC.burnin = 30000, MCMC.interval = 2048*4 ) ) Increase the sample size so the curves are more smooth, longer intervals (thinning) so we reduce the autocorrelation, larger burin. All this together to improve the Gelman test statistic. We also added idegree from 0 to 10, and esp from 0 to 3 to explicitly match those statistics in our model. knitr::include_graphics(&quot;awful-chains.png&quot;) Figure 5.2: An example of a terrible ERGM (no convergence at all). Also, a good example of why running multiple chains can be useful References "],
["more-on-mcmc-convergence.html", "5.5 More on MCMC convergence", " 5.5 More on MCMC convergence For more on this issue, I recommend reviewing chapter 1 and chapter 6 from the Handbook of MCMC (Brooks et al. 2011). Both chapters are free to download from the book’s website. For GOF take a look at section 6 of ERGM 2016 Sunbelt tutorial, and for a more technical review you can take a look at (Hunter, Goodreau, and Handcock 2008). References "],
["separable-temporal-exponential-family-random-graph-models.html", "Chapter 6 (Separable) Temporal Exponential Family Random Graph Models", " Chapter 6 (Separable) Temporal Exponential Family Random Graph Models This tutorial is great! https://statnet.org/trac/raw-attachment/wiki/Sunbelt2016/tergm_tutorial.pdf "],
["datasets.html", "A Datasets ", " A Datasets "],
["sns-data.html", "A.1 SNS data", " A.1 SNS data A.1.1 About the data This data is part of the NIH Challenge grant # RC 1RC1AA019239 “Social Networks and Networking That Puts Adolescents at High Risk”. In general terms, the SNS’s goal was(is) “Understand the network effects on risk behaviors such as smoking initiation and substance use”. A.1.2 Variables The data has a wide structure, which means that there is one row per individual, and that dynamic attributes are represented as one column per time. photoid Photo id at the school level (can be repeated across schools). school School id. hispanic Indicator variable that equals 1 if the indivual ever reported himself as hispanic. female1, …, female4 Indicator variable that equals 1 if the individual reported to be female at the particular wave. grades1,…, grades4 Academic grades by wave. Values from 1 to 5, with 5 been the best. eversmk1, …, eversmk4 Indicator variable of ever smoking by wave. A one indicated that the individual had smoked at the time of the survey. everdrk1, …, everdrk4 Indicator variable of ever drinking by wave. A one indicated that the individual had drink at the time of the survey. home1, …, home4 Factor variable for home status by wave. A one indicates home ownership, a 2 rent, and a 3 a “I don’t know”. During the survey, participants were asked to name up to 19 of their school friends: sch_friend11, …, sch_friend119 School friends nominations (19 in total) for wave 1. The codes are mapped to the variable photoid. sch_friend21, …, sch_friend219 School friends nominations (19 in total) for wave 2. The codes are mapped to the variable photoid. sch_friend31, …, sch_friend319 School friends nominations (19 in total) for wave 3. The codes are mapped to the variable photoid. sch_friend41, …, sch_friend419 School friends nominations (19 in total) for wave 4. The codes are mapped to the variable photoid. "],
["references.html", "References", " References "]
]
